"""
client.py
Usage: python client.py <server_ip> [--simulate-cpu]

Connects to server TCP port 9999, receives jobs, does CPU or sleep,
sends heartbeat and sends done messages.
"""
import socket
import sys
import threading
import time
import json

TCP_PORT = 9999
HEARTBEAT_INTERVAL = 2.0

def cpu_heavy(service_time):
    iterations = int(150000 * max(1.0, service_time))
    acc = 0
    for i in range(iterations):
        acc += (i ^ (i << 1)) & 0xFFFF
    return acc

def send_heartbeat(sock, client_id):
    while True:
        try:
            sock.sendall((json.dumps({"type":"heartbeat","id":client_id}) + "\n").encode())
        except Exception:
            break
        time.sleep(HEARTBEAT_INTERVAL)

def handle_server(sock, simulate_cpu):
    buf = b''
    client_id = None
    while True:
        data = sock.recv(4096)
        if not data:
            print("[CLIENT] server closed")
            break
        buf += data
        while b'\n' in buf:
            line, buf = buf.split(b'\n', 1)
            if not line: continue
            try:
                msg = json.loads(line.decode())
            except:
                continue
            typ = msg.get('type')
            if typ == 'assign':
                client_id = msg.get('id')
                print("[CLIENT] assigned id", client_id)
                threading.Thread(target=send_heartbeat, args=(sock,client_id), daemon=True).start()
            elif typ == 'job':
                cust = msg.get('customer_id')
                st = float(msg.get('service_time', 2.0))
                print(f"[CLIENT] Received job {cust} st={st}")
                if simulate_cpu:
                    cpu_heavy(st)
                else:
                    time.sleep(st)
                done = {"type":"done", "customer_id": cust, "service_time": st}
                try:
                    sock.sendall((json.dumps(done) + "\n").encode())
                except Exception as e:
                    print("[CLIENT] failed to send done", e)

def main():
    if len(sys.argv) < 2:
        print("Usage: python client.py <server_ip> [--simulate-cpu]")
        sys.exit(1)
    server_ip = sys.argv[1]
    simulate_cpu = ("--simulate-cpu" in sys.argv)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((server_ip, TCP_PORT))
    print("[CLIENT] Connected to server", server_ip)
    handle_server(sock, simulate_cpu)

if __name__ == "__main__":
    main()






client.py















"""
server.py - Banking Multiprogramming Server
-------------------------------------------
- TCP worker server (port 9999)
- Dispatches customers to workers (clients)
- Tracks counters like a real bank
- Flask-SocketIO dashboard on port 5000
"""

import socket
import threading
import json
import time
import random
import queue
import sqlite3
from multiprocessing import Pool
from flask import Flask, send_from_directory
from flask_socketio import SocketIO

# ---------------- CONFIG ----------------
HOST = ""
TCP_PORT = 9999
WS_PORT = 5000

HEARTBEAT_INTERVAL = 2.0
HEARTBEAT_TIMEOUT = 6.0

CUSTOMER_MEAN = 1.2
SERVICE_MIN = 2.0
SERVICE_MAX = 5.0

LOCAL_CPU_WORKERS = 0  # No local counters now (only remote clients)

DB_FILE = "server_data.db"

# ---------------- DB helper ----------------
def init_db():
    conn = sqlite3.connect(DB_FILE)
    c = conn.cursor()
    c.execute("""
        CREATE TABLE IF NOT EXISTS customers (
            id INTEGER PRIMARY KEY,
            arrival REAL,
            dispatched REAL,
            started REAL,
            finished REAL,
            service_time REAL,
            assigned_worker TEXT
        )
    """)
    conn.commit()
    conn.close()

def db_upsert(cust):
    conn = sqlite3.connect(DB_FILE)
    c = conn.cursor()
    c.execute("""
        INSERT OR REPLACE INTO customers
        (id, arrival, dispatched, started, finished, service_time, assigned_worker)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    """, (
        cust.get("customer_id"),
        cust.get("arrival"),
        cust.get("dispatched"),
        cust.get("started"),
        cust.get("finished"),
        cust.get("service_time"),
        cust.get("assigned_worker"),
    ))
    conn.commit()
    conn.close()

# ---------------- Flask Dashboard ----------------
app = Flask(__name__, static_folder="static")
sio = SocketIO(app, async_mode="threading", cors_allowed_origins="*")

@app.route("/")
def index():
    return send_from_directory("static", "index.html")

# ---------------- Shared State ----------------
central_queue = queue.Queue()
clients = {}       # client_id → {sock, busy, addr, last_heartbeat, current_job}
clients_lock = threading.Lock()

metrics = {"total_generated": 0, "total_dispatched": 0, "total_completed": 0}
metrics_lock = threading.Lock()

local_pool = None

# ---------------- Customer Generator ----------------
cust_seq = 1
def customer_generator(stop):
    global cust_seq
    while not stop.is_set():
        time.sleep(max(0.3, random.expovariate(1.0 / CUSTOMER_MEAN)))
        cid = cust_seq
        cust_seq += 1
        st = round(random.uniform(SERVICE_MIN, SERVICE_MAX), 2)
        cust = {"customer_id": cid, "arrival": time.time(), "service_time": st}
        central_queue.put(cust)
        db_upsert(cust)

        with metrics_lock:
            metrics["total_generated"] += 1

        print(f"[GEN] New customer {cid} st={st}")
        emit_snapshot()

# ---------------- Dispatcher ----------------
def dispatcher(stop):
    while not stop.is_set():
        try:
            cust = central_queue.get(timeout=0.5)
        except queue.Empty:
            continue

        assigned = False

        with clients_lock:
            for cid, info in clients.items():
                if not info["busy"]:
                    try:
                        msg = {
                            "type": "job",
                            "customer_id": cust["customer_id"],
                            "service_time": cust["service_time"]
                        }
                        info["sock"].sendall((json.dumps(msg) + "\n").encode())
                        info["busy"] = True
                        info["current_job"] = cust
                        info["last_heartbeat"] = time.time()

                        cust["dispatched"] = time.time()
                        cust["started"] = time.time()
                        cust["assigned_worker"] = cid
                        db_upsert(cust)

                        with metrics_lock:
                            metrics["total_dispatched"] += 1

                        print(f"[DISPATCH] Customer {cust['customer_id']} → {cid}")
                        assigned = True
                        break
                    except:
                        continue

        if not assigned:
            central_queue.put(cust)

        emit_snapshot()

# ---------------- Heartbeat Monitor ----------------
def monitor_clients(stop):
    while not stop.is_set():
        now = time.time()
        dead = []

        with clients_lock:
            for cid, info in list(clients.items()):
                if now - info["last_heartbeat"] > HEARTBEAT_TIMEOUT:
                    print(f"[MONITOR] {cid} TIMED OUT")
                    if info["current_job"]:
                        central_queue.put(info["current_job"])
                    dead.append(cid)

            for cid in dead:
                clients.pop(cid, None)

        emit_snapshot()
        time.sleep(1)

# ---------------- TCP Server ----------------
def accept_clients(stop):
    serv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    serv.bind((HOST, TCP_PORT))
    serv.listen(10)
    serv.settimeout(1)
    print(f"[TCP] Listening on port {TCP_PORT}")

    while not stop.is_set():
        try:
            conn, addr = serv.accept()
        except socket.timeout:
            continue

        cid = f"client_{int(time.time()*1000)%100000}"
        clients[cid] = {
            "sock": conn,
            "addr": addr,
            "busy": False,
            "last_heartbeat": time.time(),
            "current_job": None
        }

        print(f"[TCP] Connected: {cid} from {addr}")
        conn.sendall((json.dumps({"type": "assign", "id": cid}) + "\n").encode())

        threading.Thread(target=client_recv_loop, args=(cid, conn), daemon=True).start()
        emit_snapshot()

def client_recv_loop(cid, conn):
    buf = b""
    while True:
        data = conn.recv(4096)
        if not data:
            break

        buf += data
        while b"\n" in buf:
            line, buf = buf.split(b"\n", 1)
            if not line:
                continue
            msg = json.loads(line.decode())
            handle_message(cid, msg)

    print(f"[TCP] Closed: {cid}")
    with clients_lock:
        clients.pop(cid, None)
    emit_snapshot()

def handle_message(cid, msg):
    typ = msg.get("type")

    if typ == "heartbeat":
        clients[cid]["last_heartbeat"] = time.time()

    elif typ == "done":
        cust_id = msg["customer_id"]
        clients[cid]["busy"] = False
        clients[cid]["current_job"] = None

        db_upsert({
            "customer_id": cust_id,
            "finished": time.time(),
            "assigned_worker": cid
        })

        with metrics_lock:
            metrics["total_completed"] += 1

        print(f"[DONE] {cid} finished customer {cust_id}")

    emit_snapshot()

# ---------------- Dashboard Snapshot ----------------
def make_snapshot():
    with clients_lock:
        counters = []
        idx = 1
        for cid, info in clients.items():
            counters.append({
                "counter": f"Counter {idx}",
                "worker": cid,
                "busy": info["busy"],
                "customer": info["current_job"]["customer_id"] if info["busy"] else None,
                "service_time": info["current_job"]["service_time"] if info["busy"] else None
            })
            idx += 1

    qsize = central_queue.qsize()
    queue_preview = list(central_queue.queue)[:10]

    with metrics_lock:
        m = metrics.copy()

    return {
        "queue_size": qsize,
        "queue_preview": queue_preview,
        "counters": counters,
        "metrics": m,
        "time": time.time()
    }

def emit_snapshot():
    sio.emit("snapshot", make_snapshot())

# ---------------- Main ----------------
def run_server():
    stop = threading.Event()

    threads = [
        threading.Thread(target=accept_clients, args=(stop,), daemon=True),
        threading.Thread(target=customer_generator, args=(stop,), daemon=True),
        threading.Thread(target=dispatcher, args=(stop,), daemon=True),
        threading.Thread(target=monitor_clients, args=(stop,), daemon=True),
    ]

    for t in threads:
        t.start()

    return stop

if __name__ == "__main__":
    print("[SERVER] Initializing database...")
    init_db()

    stop_event = run_server()

    print(f"[SERVER] Dashboard at http://0.0.0.0:{WS_PORT}")
    sio.run(app, host="0.0.0.0", port=WS_PORT)







//server.py
